# Лабораторная работа 3

## Настройка PS часть 2 и периферийные устройства MIO

## Обзор

В большинстве обучающих руководств по *Zynq* показано, как с предустановленной конфигурацией (preset Configuration) для конкретной платы приступить к созданию приложений. Однако в руководствах обычно не показано, как была создана эта конфигурация. Если вы не разрабатываете идентичную копию платы разработки, вам необходимо знать, как создать дизайн без предварительно существующей конфигурации.  С некоторыми основами этого вы уже познакомились в лабораторной работе 2.  Теперь мы завершим это упражнение.

Кроме того, настоятельно рекомендуется, чтобы все разработчики *Zynq* выполнили эту работу, прежде чем производить соединения на схеме/плате. Это поможет разработчикам увидеть, какие периферийные устройства могут поместиться в *MIO*, поскольку только часть доступных периферийных устройств может быть подключено к *MIO*. Кроме того, количество доступных позиций *MIO*, на которые можно сопоставить входы/выходы этих периферийных устройств, ограничено.  Установка критически важных периферийных устройств на существующие позиции в *MIO* и сопоставление остальных с позициями в *EMIO* - это задача проектирования, и *IP Integrator* покажет, какие периферийные устройства куда могут быть размещены.

## Цель работы

После выполнения лабораторной работы вы сможете:

* Включать и размещать все доступные периферийные устройства в IP Integrator
* Выставлять клоки PS для периферии PS и PL
* Создавать и запускать следующие программы на Си:
    * Peripheral Test
    * Memory Test

## Эксперимент 1: Включение и размещение всей периферии PS

Этот эксперимент покажет, как разместить периферию PS на нашей плате.

---

### **Обобщенная инструкция:**

В существующем проекте в *Vivado Block Design* настройте встроенное ядро *ARM* таким образом, чтобы включить *QSPI*, *Ethernet*, *USB*, *SD Card*, *GPIO*.Разместите эту периферию в MIO, в соответствии с конфигурацией платы *ZedBoard*.

---

### **Пошаговая инструкция:**

1. Для данной лабораторной работы необходимо использовать существующий проект из второй лабораторной работы.

2. В *Vivado* в боковой панели *IP Integrator* откройте **Block Design**.

    ![Открыть блочный дизайн](./resources/lab3/Open%20Block%20Design.png)

3. Дважды кликните на **ZYNQ7 Processing System** для рекастомизации процессорного ядра.

4. В боковой панели *Page Navigator* нажмите на **MIO Configuration** и на **Expand all**, чтобы увидеть все доступные периферийные устройства.

    ![MIO COnfiguration](./resources/lab3/MIO%20Configuration.png)

    Самое важное - это устройство загрузки (boot device). Zynq позволяет выбрать между *QSPI*, *NOR*, *NAND*. Обратите внимание, что *SD Card* также может служить устройство загрузки, он появится ниже в списке. Наша плата *ZedBoard* имеет вшитую в плату *Spansion Quad SPI Flash*.

5. Активируйте чекбокс **Quad SPI Flash**.

6. Раскройте список *Quad SPI Flash*. Убедитесь, что чекбокс **Feedback Clk** возможно установить. Активируйте этот чекбокс. Заметьте, что мы также можем активировать второй *QSPI* в конфигурации *Dual* (не делайте это для данной работы). Обратите внимание на то, что периферийное устройство *QSPI* имеет фиксированную позицию в *MIO* - [1-6,8].

    ![Конфигурация QSPI](./resources/lab3/QSPI%20Flash%20Connections.png)

    Обратите внимание, что теперь интерфейсы *SRAM/NOR Flash* и *NAND Flash* не могут быть выбраны. Опять же это из-за того что для *Zynq PS* может быть выбрано только один интерфейс памяти.

    Следующим периферийным устройством в списке является *Ethernet*. Исходя из того, что ранее было сказано о порядке приоритета сверху вниз, *Ethernet* должен быть наименее гибким интерфейсом, после *Flash device*.    Однако это не так. На самом деле наименее гибким является *USB*. Для него требуется меньше пинов, но *USB* должен быть подключен к MIO, как и флэш-память. *Ethernet* может быть подключен к *EMIO*. Поэтому мы пока пропустим Ethernet и перейдем к USB.

7. Включите **USB 0**. Раскройте список *USB 0*. Заметьте, что для USB расположен в *MIO[28-39]* с напряжением *LVCMOS 1.8V*.

    ![Соединения USB 0](./resources/lab3/USB%200%20Connections.png)

8. Теперь подключим **ENET 0**. Активируйте соответствующий чекбокс. Выберите для него пины **MIO[16-27]**. В раскрывающемся списке *ENET0* активируйте чекбокс **MDIO**. Для *MDIO* выберите пины **MIO[52-53]**. Обратите внимание, что напряжение задано *LVCMOS 1.8V*.

    ![Соединения Ethernet 0](./resources/lab3/Ethernet%200%20Configuration.png)

9. Дальше по списку активируйте **SD 0** и подключите кго ко входам **MIO[40-45]**. В раскрывающемся списке активируйте **CD** - **MIO 47** и **WP** - **MIO 46**.

    ![Соединения SD 0](./resources/lab3/SD%200%20Connections.png)

10. До этого мы уже активировали **UART**. Оставшиеся неиспользуемы входы/выходы используются для *PS Pmod* (8 I/Os), *LED* (1 I/O), *PB* (1 I/O). *LED* и *PB* будут использованы в качестве *GPIO*, которые мы установим последними. Рассмотрим *PS Pmod*.

    Разработчики платы *ZedBoard* решили использовать 8 входов/выходов MIO для *PS Pmod*. Этими 8-и входами являются *MIO[0, 9-15]*. Желательно бы было использовать непрерывный диапазон входом, однако это не представляется возможным. *MIO[7-8]* не были включены, поскольку они в отличие остальных пинов являются только выходами. Поэтому *MIO[7]* мы будем соединять с *LED*. *MIO[8]* уже используется с интерфейсом *QSPI Flash*. ZedBoard предоставляет 7 пользовательских кнопок, соединенных с GPIO. 5 на стороне *PL* и 2 на стороне *PS* (MIO[50:51]).

11. Раскройте список с *GPIO*. Активируйте чекбокс **GPIO MIO**. Деактивируйте любые чекбоксы связанные со сбросом (Reset).

    ![Ресеты GPIO](./resources/lab3/GPIO%20RESETS.png)

12. При включении *GPIO* c *MIO* Vivado автоматически расположит оставшиеся пины под GPIO.

13. Чтобы увидеть какие еще интерфейсы мы можем подключить к свободным входам/выходам *MIO* в боковой панели *Page Navigator* откройте **Peripheral I/O Pins**. входы окрашенные зеленым уже заняты.

    ![Соединения MIO](./resources/lab3/All%20MIO%20Connections.png)

### **Вопросы:**

* Почему мы не можем подключить *USB 0* к *EMIO*?
* У каких других интерфейсов вы ожидаете не увидеть подключение к *EMIO*? почему
* Что за *Power pin* у интерфейсов SD?
* 12 периферий может быть подключено к *PS Pmod*. Найдите ту, которая не может?
* Доступен ли для ZedBoard *Processor JTAG*? Если да, как его использовать?
* Назовите один сценарий, при котором независимый доступ к *PJTAG* может быть полезен.
* Что особенного у MIO[7] и MIO[8]?


## Эксперимент 2: Установка тактовых сигналов PS PLL

Теперь, когда у нас включено больше периферийных устройств PS, нам нужно еще раз рассмотреть тактовые сигналы. Мы также рассмотрим клоки, которые PS может передавать в PL.

---

### **Обобщенная инструкция:**

Сконфигурируйте тактовые сигналы PS для только что добавленной периферии. Установите тактовые частоты *PL Fabric*, а также тактовые частоты CPU и DDR.

---

### **Пошаговая инструкция:**

1. В боковой панели *Page Navigator* откройте **Clock Configuration**. Раскройте все списки клоков, нажав **Expand All**.

    ![Клоковый волшебник](./resources/lab3/PS%20Clock%20Wizard.png)

    Напоминаем, что *Zynq PS* имеет три *PLL* - *ARM*, *DDR* и *I/O*. Каждый использует одинаковую референсную частоту 33.3333 МГц.

    Каждая PLL должна быть настроена таким образом, чтобы выдавать частоту в определенном диапазоне, указанном в датащите. Для устройств с *Speed Grade* *-1* диапазон - 780 - 1600 МГц.

2. Удостоверьтесь, что введены следующие настройки для генераторов таков PS:
    * *Input frequency* = **33.33333MHz**
    * *CPU frequency* = **666.666666MHz**
    * *DDR frequency* = **533.333333MHz**

    Эти настройки определили выходную частоту *PLL* для *ARM* и *DDR*, обе из которых должны быть кратны **33.333 MГц**. Поскольку частота CPU должна быть целочисленным делителем *ARM PLL*, мы знаем, что *ARM PLL* должен быть установлен в **1333.33 MГц** (33.333 МГц \* 40) и после этого делитель для частоты CPU должен быть **2**. Выходная частота *DDR PLL* может быть или **1600 МГц** (33.333 \* 48), или **1066.667 МГц** (33.333 * 32). По умолчанию, система устанавливает частоту в 1066.667 МГц и использует делитель 2.

    Все остальное, что использует эти *PLL* должно использовать целочисленный делитель для заданной выходной частоты. Такой же принцип применяется и к *I/O PLL*.

    Подобно тому, как CPU и DDR являются определяющими факторами для настройки ARM и DDR PLL, I/O PLL также имеет более приоритетные зависимости. Наиболее доминирующим является *Ethernet*. Функциональность *Ethernet* сильно зависит от точных настроек частот.

3. Установите *ENET0* в **1000 Mbps**.
![Настройка ENet0](./resources/lab3/Enet0%20Set%20to%201000%20Mbps.png)

    Обратите внимание, что поле *Actual Frequency* установилось в значение **125 MHz**. Если вы дружите с математикой, то поймете, что выходная частота *I/O PLL* должна быть или **1000 МГц** (33.333 МГц \* 30) или 1600 МГц (33.333 МГц \* 45). В данной ситуации мы устанавливаем *I/O PLL* в 1000 МГц.

4. По-умолчанию периферия *QSPI* использует *I/O PLL* как источник тактовых импульсов. *QSPI* работает на максимальной частоте в 100 МГц. Оно имеет внутренний делитель частоты, который по-умолчанию установлен в **2**. Мы не будем менять это значение, поэтому установим частоту входного такого сигнала в **200 MHz**

    ![Настройка QSPI](./resources/lab3/QSPI%20Requested%20Frequency%20Set%20to%20200%20MHz.png)

5. Установите *SDIO* в **50 MHz**.

    ![Настройка SDIO](./resources/lab3/SDIO%20Requested%20Frequency%20Set%20to%2050%20MHz.png)

6. PS также умеет управлять 4-мя тактовыми сигналами в PL. Включите и установите в следующие значения:
    
    * FCLK_CLK0 - 100 MHz
    * FCLK_CLK1 - 150 MHz
    * FCLK_CLK2 - 50 MHz
    * FCLK_CLK3 - 25 MHz

7. Правильные настройки клоков критически важны для правильной работы периферии в следующих лабораторных работах, поэтому проверьте правильность введенных значений перед продолжением дальнейших экспериментов.

    ![Настройка клоков](./resources/lab3/Clock%20Settings.png)

8. Отключите все *Fabric Cloks*, так как они пока нам не нужны. Мы включали их, чтобы продемонстрировать возможности PLL, в конце по этим клокам будет вопрос.

    ![то включи, то выключи..](./resources/lab3/Clock%20Configiration.png)

9. Закройте *Zynq Block Design*, нажав кнопку **OK**.

10. **Validate (F6)** the *Block Design*.

11. **Сохраните** *Block Design*.

12. *Block Design* это всего лишь графическая репрезентация некоторого HDL-кода, который будет сгенерирован нашей системой. Код и файлы, сгенерированные *Block Design* являются **Output Products**.Когда мы в первый раз сгенерировали битстрим, система автоматически сгенерировала для нас *Output Products*. Теперь мы модифицировали *Block Design*. Вообще система должна задетектить изменения нашего *Block Design* и сгенерировать наши *Output Products* заново. Однако для большей безопасности мы вручную удалим файлы и сгенерируем *Output Products*.

    Раскройте список *Design Sources*. Нажмите правой кнопкой мыши на **Z_system_i** и нажмите **Reset Output Products..**. Нажмите **Reset** в всплывшем окне для подтверждения удаления.

    ![Удаление выходных файлов](./resources/lab3/Reset%20Output%20Products.png)

13. Нажмите правой кнопкой мыши на **Z_system_i** и нажмите **Generate Output Products..**.

    ![Генерация выходных файлов](./resources/lab3/Generate%20Output%20Products.png)

14. убедитесь, что *Synthesis Options* установлен в **Global**. Нажмите **Generate**.

15. Выберите **Generate Bitstream**. Это перезапустит синтез и имплементацию. Если спросит, уверены ли вы, нажмите **Yes**.

16. Откройте *Implemented design*. Если эта попап с этой опцией не появился, нажмите **Cancel**, откройте *implemented design*  боковой панели и выберите **Reload**.

---

### **Вопросы:**

* Обратите внимание, что *Actual Frequency* для *FCLK_CLK1* не соответствует *Requested Frequency*. Почему?

## Эксперимент 3: Создание и запуск тестового приложения

Когда у нас больше периферии, добавленной в PS, мы можем использовать более продвинутые тестовые приложения.

---

### **Обобщенная инструкция:**

Экспортируйте в *SDK*. Сгенерируйте Memory и Peripheral test application.

---

### **Пошаговая инструкция:**

1. Vitis должен быть закрыт. Если открыт, закройте.

2. Экспортируйте в SDK, как вы это делали в 2 лабораторной работе. Выберите **File -> Export -> Export Hardware...**

    До этого мы давали Vivado управлять локацией экспортированной платформы. Мы также запускали Vitis из Vivado. Это хорошо работает для первого экспорта, однако последующие экспорты могут стать жертвой ошибок. Для избегания их появления, рекомендуем вручную управлять локацией для экспорта и *Vitis Workspace*.

3. В появившемся окне *Export Hardware Platform* нажмите кнопку **Next**. В следующем окне выберите **Include Bitstream** и нажмите кнопку **Next** в текущем и следующем окне. Затем нажмите кнопку **Finish**.

    ![Экспорт hard](./resources/lab2/Export%20Hard.png)

4. В поле *Export to* введите `C:/ZynqHW/2023.1/ZynqDesign/ZynqDesign.lab3`. Нажмите **Next** и **Finish**.

    ![Поменять имя](./resources/lab3/Launch%20SDK%20Dialog%20Box.png)

5. Нажмите **Tools->Launch Vitis IDE**.

6. Измените локацию *Workspace*. Нажмите **Launch**.

    ![Изменить воркспейс](./resources/lab3/Launch%20IDE%20Dialog%20box.png)

7. Создайте *Platform Project* и *Application Project* как мы это делали во второй лабораторной работе. В качестве проверки запустите Hello_world.

8. Сгенерируем *Memory Test* приложение:

    * **File -> New -> Application Project**.
    * Введите *Project Name* `Memory_Tester`.
    * Выберите *Domain* **standalone_domain**.
    * Выберите **Memory Tests** нажмите **Finish**.
    * Сбилдьте проект.
    * Запустите приложение.

    ![Результаты запуска](./resources/lab3/Memory%20Test%20Results.png)

9. Аналогичную процедуру проведите для **Peripheral Tests**.

    Примечание: Иногда PHY перестает отвечать на запросы после выполнения предыдущих тестов, оставляющих аппаратное обеспечение в неопределенном состоянии, что приводит к ложному сбою оборудования.  Если вы столкнулись с этим, вы можете устранить его, выключив/включив питание платы MicroZed и повторно запустив тест периферийного устройства.  Одной из альтернатив циклическому включению питания является изменение *Run Configuration* для этого приложения и замена опции *Reset Processor* на опцию *Reset Entire System* и запуск приложения на целевой плате.

10. Закройте IDE.

11. Закройте Vivado.

---

### **Вопросы:**

* Посмотрите на результаты теста памяти. Что такое базовый адрес (Base Address) для Memory Test?

* Почему DDR не начинается с адреса 0?

## Дальнейшее изучение

При наличии свободного времени можно также изучить:

* Модифицируйте *Memory Test* таким образом, чтобы протестировать все адресное пространство. Подсказка - посмотрите на функцию *test_memory_range* в *memorytest.c*.

## Источники:

www.microzed.org

www.picozed.org

www.zedboard.org

www.xilinx.com/zynq

www.xilinx.com/sdk

www.xilinx.com/vivado

www.xilinx.com/support/documentation/sw_manuals/ug949-vivado-design-methodology.pdf

www.xilinx.com/support/documentation/sw_manuals/ug1046-ultrafast-design-methodology-guide.pdf

## Ответы

> Почему мы не можем подключить *USB 0* к *EMIO*?

Стандарт *ULPI* для *USB* устанавливает тайминги для прохождения сигнала, которые не могут быть соблюдены при прохождении через *EMIO*.

> У каких других интерфейсов вы ожидаете не увидеть подключение к *EMIO*? почему

3 Flash-устройства не могут быть подключены к *EMIO*, так как Flash-память является устройством загрузки (boot-device).

> Что за *Power pin* у интерфейсов SD?

Это управляющий выход для включения/выключения питания у слота SD-карты.

> 12 периферий может быть подключено к *PS Pmod*. Найдите ту, которая не может?

*SP0* и *Trace* (*clk*, *ctl*, и *d[3:0]*; *d[15:4]* должны быть соединены с EMIO). Следующая периферия может быть подключена к *PS Pmod*: *Dual Quad*, *SPI*, *SD 1*, *UART 0*, *I2C 0*, *I2C 1*, *SPI 1*, *CAN 0*, *CAN 1*, *Watchdog*, *PJTAG*, *GPIO*.

> Доступен ли для ZedBoard *Processor JTAG*? Если да, как его использовать?

Да, доступен. Вы можете получить доступ к ARM JTAG в каскадном режиме JTAG (cascaded JTAG mode) через разделяемый JTAG. Independent Processor JTAG также доступен через PS Pmod. Для этого потребуются следующие шаги:

* Перед включением питания установите boot_mode[3] в 1 для *Independent JTAG*.
* Должен выполниться небольшой конфигурационный код, для настройки *MIO[10-13]* в качестве *PJTAG*.
* Для доступа к *PJTAG* используйте *PS Pmod*.

> Назовите один сценарий, при котором независимый доступ к *PJTAG* может быть полезен.

Совместная отладка *Hardware/Software*. Стандартный порт *JTAG* используется для *Vivado Analyzer*, в то время как *PS Pmod PJTAG* используется для процессорной отладки с помощью *ARM DS-5* или *DSTREAM*.

> Что особенного у MIO[7] и MIO[8]?

Они работают только на выход.

> Обратите внимание, что *Actual Frequency* для *FCLK_CLK1* не соответствует *Requested Frequency*. Почему?

PLL имеет ограниченное количество соотношений M/N для генерации разных частот. Как только мы установили *ENET* в *1000 Mbps*, у нас появилось требование к частоте в 125 МГц. Частота референсного клока 33.3333 МГц. PLL преобразует его в 1 ГГц, чтобы потом получить 125 МГц. *FCLK_CLK1* требует от нас частоту в 150 МГц. Ближайшее, что мы можем использовать - 142.857 МГц при использовании делителя 7.

> Посмотрите на результаты теста памяти. Что такое базовый адрес (Base Address) для Memory Test?

0x00100000

> Почему DDR не начинается с адреса 0?

Именно здесь находится OCM. Вы можете перенастроить DDR, чтобы базовый адрес находился по адресу 0x0, но обычно это делается на 2-м этапе bootloader.